[% import 'Util.eol'; %]
package [%=packageName%];


import java.lang.reflect.Method;
import java.lang.reflect.Type;
import java.util.List;

import org.vaultage.core.Vault;
import org.vaultage.core.Vaultage;
import org.vaultage.core.VaultageMessage;
import org.vaultage.core.VaultageMessage.MessageType;
import org.vaultage.wallet.PaymentInformation;
import org.vaultage.wallet.Wallet;

public class [%=class.remoteName()%] {

	//protected [%=class.name%] localVault;
	protected Vault localVault;
	protected String remotePublicKey;

	public String getRemotePublicKey() {
		return remotePublicKey;
	}

	//public [%=class.remoteName()%]([%=class.name%] localVault, String remotePublicKey) {
	public [%=class.remoteName()%](Vault localVault, String remotePublicKey) {
		this.localVault = localVault;
		this.remotePublicKey = remotePublicKey;
	}
[% for (eOperation in class.eOperations) { %]

	public String [%= eOperation.name %]([%=eOperation.getParams()%]) throws Exception {
	[% if ( eOperation.eParameters.size() > 0) { %]
		return this.[%= eOperation.name %]([%=eOperation.getParamsWithoutTypes()%], true);
	[% } else { %]
		return this.[%= eOperation.name %](true);
	[% } %]
	}
[% if ( eOperation.eParameters.size() > 0) { %]
	public String [%= eOperation.name %]([%=eOperation.getParams()%], boolean isEncrypted) throws Exception {
[% } else { %]
	public String [%= eOperation.name %](boolean isEncrypted) throws Exception {
[% } %]
		VaultageMessage request = new VaultageMessage();
		request.initToken();
		request.setSenderId(localVault.getId());
		request.setFrom(localVault.getPublicKey());
		request.setTo(remotePublicKey);
		request.setMessageType(MessageType.REQUEST);
		request.setOperation("[%= eOperation.name %]");
		
	[% for (eParamater in eOperation.eParameters) { %]
		request.putValue("[%=eParamater.name%]", Vaultage.serialise([%=eParamater.name%]));
	[% } %]
	
	[%	var eAnnotation = eOperation.eAnnotations.selectOne(e | e.source = "vaultage");
	if (eAnnotation <> null and eAnnotation.details.one(e | e.key = "monetised" and e.value = "true")) { %]
		Wallet wallet = this.localVault.getVaultage().getDefaultWallet();
		PaymentInformation paymentInformation = new PaymentInformation(); 
		paymentInformation.setName(wallet.getName());
		paymentInformation.setType(wallet.getType());
		paymentInformation.setCurrency(wallet.getCurrency());
		paymentInformation.setAccountNumber(wallet.getAccountNumber());
		paymentInformation.setBank(wallet.getBank());
		paymentInformation.setBankAddress(wallet.getBankAddress());
		paymentInformation.setBillAddress(wallet.getBillAddress());
		request.setPaymentInformation(paymentInformation);
	[% } %]
	
		localVault.getVaultage().sendMessage(request.getTo(), localVault.getPublicKey(),
				localVault.getPrivateKey(), request, isEncrypted);

		return request.getToken();
	}
	[% if (eOperation.getReturnType() <> null and eOperation.getReturnType() <> "void") { %]
	
	public void respondTo[%=eOperation.name.firstToUpperCase()%]([%=eOperation.getReturnType() %] result, String token) throws Exception {
		this.respondTo[%=eOperation.name.firstToUpperCase()%](result, token, true);
	}
	
	public void respondTo[%=eOperation.name.firstToUpperCase()%]([%=eOperation.getReturnType() %] result, String token, boolean isEncrypted) throws Exception {
		
		VaultageMessage response = new VaultageMessage();
		response.setToken(token); // TODO: this token is not known by the vault
		response.setFrom(localVault.getPublicKey());
		response.setTo(remotePublicKey);
		response.setOperation("[%=eOperation.name%]");
		response.setMessageType(MessageType.RESPONSE);
		response.setRemoteVaultType(this.getClass().getName());
		
		Method m = new Object(){}.getClass().getEnclosingMethod();
		Type x = m.getGenericParameterTypes()[0];
		String returnType = x.getTypeName();
		response.setReturnType(returnType);

		response.putValue("result", Vaultage.serialise(result));

		localVault.getVaultage().sendMessage(response.getTo(), localVault.getPublicKey(),
				localVault.getPrivateKey(), response, isEncrypted);
	}
	[% } %]
[% } %]	
}
